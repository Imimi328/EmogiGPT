<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emogi Chatbot</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'/>">

  <!-- Marked UMD + marked-highlight UMD -->
  <script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>

  <!-- highlight.js + style -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css" />

  <!-- DOMPurify (sanitize rendered HTML) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>

</head>
<body>
  <aside>
    <div class="sidebar-header">
      <button id="new-chat" class="btn" title="Start new chat">+ New</button>
      <button id="delete-chat" class="btn" title="Delete current chat">ðŸ—‘</button>
      <span class="brand">Emogi</span>
    </div>
    <div id="chat-list" class="chat-list"></div>
    <div class="sidebar-footer">Emogi Chatbot</div>
  </aside>

  <main>
    <header>
      <div class="header-actions">
        <button id="theme-toggle" class="btn" title="Toggle theme" aria-pressed="false">ðŸŒ“</button>
      </div>
      <div id="chat-title" class="header-title">New Chat</div>
      <div class="header-actions">
        <div class="lang-selects" style="display:flex; gap:6px; align-items:center;">
          <label for="src-lang" style="font-size:.85em; color:var(--muted);">Input</label>
          <select id="src-lang" class="btn" style="padding:8px;">
            <option value="auto">Auto</option>
          </select>
          <label for="tgt-lang" style="font-size:.85em; color:var(--muted);">Reply</label>
          <select id="tgt-lang" class="btn" style="padding:8px;">
            <option value="same">Same</option>
          </select>
        </div>
        <span id="latency-chip" class="btn" title="Last response time" style="opacity:.8; cursor:default;">â€“ ms</span>
      </div>
    </header>

    <div id="banner" role="status" aria-live="polite" aria-atomic="true"></div>

    <div id="chat-container"></div>

    <section id="empty-state" class="empty-state" hidden>
      <div class="empty-title">Start a conversation</div>
      <div class="empty-sub">Ask for code help, translations, summaries, or ideas.</div>
      <div class="empty-chips" id="empty-chips"></div>
    </section>

    <form id="input-form" novalidate>
      <input type="text" id="input" placeholder="Type a message..." autocomplete="off" required enterkeyhint="send" />
      <button type="button" id="stop" title="Cancel inâ€‘flight request">Stop</button>
      <button type="submit" id="send">Send</button>
    </form>
  </main>

  <script>
    // ========= Config =========
    // Use local LM Studio for dev (OpenAI-compatible endpoint); toggle to remote if CORS fixed
    const apiUrl = 'http://localhost:1234/v1/chat/completions'; // Local: No CORS issues [memory:1]
    // const apiUrl = 'https://api.emogi.space/v1/chat/completions'; // Remote: Needs CORS headers on server
    const modelName = 'openai/gpt-oss-20b.ggufs';
    const apiKey = ''; // Optional for local LM Studio

    const TRANS_BASE = 'http://localhost:5000'; // Local LibreTranslate/IndicTrans2 if needed; e.g., Docker on port 5000 [memory:1]
    // const TRANS_BASE = 'https://transapi.emogi.space'; // Remote: Needs CORS
    const USE_STREAM = false;
    const TRANS_TIMEOUT_MS = 15000; // 15s for local setups
    const DEBUG_PAYLOAD = true; // Set to false in production to disable console logs

    const systemPrompt =
      'You are a helpful AI model developed by Ritesh Verma, the CEO of Team Emogi. Your primary role is to assist with programming, video editing, AI, game development, and creative tasks. You represent Team Emogi, a multi-level organization working in AR/VR, AI, animation, space, and game development. Be formal and informative in your tone.';

    const STORAGE_KEY = 'emogiConversationsV7';
    const SETTINGS_KEY = 'emogiSettingsV1';

    const TIMEOUT_MS = 180000;
    const MAX_RETRIES = 3;
    const BACKOFF_BASE_MS = 600;
    const BACKOFF_CAP_MS = 8000;

    if (location.protocol === 'file:') {
      console.warn('Running from file:// may cause CORS issues for cross-origin APIs.');
      const banner = document.getElementById('banner');
      banner.textContent = 'Serve via HTTP (e.g., python -m http.server) to fix CORS. Use local LM Studio endpoint.';
      banner.style.display = 'block';
    }

    // ========= DOM ========= (unchanged)
    const chatListEl = document.getElementById('chat-list');
    const newChatBtn = document.getElementById('new-chat');
    const delChatBtn = document.getElementById('delete-chat');
    const chatTitleEl = document.getElementById('chat-title');
    const bannerEl = document.getElementById('banner');
    const chatContainer = document.getElementById('chat-container');
    const emptyState = document.getElementById('empty-state');
    const emptyChips = document.getElementById('empty-chips');
    const inputForm = document.getElementById('input-form');
    const inputField = document.getElementById('input');
    const sendButton = document.getElementById('send');
    const stopButton = document.getElementById('stop');
    const themeToggle = document.getElementById('theme-toggle');
    const latencyChip = document.getElementById('latency-chip');
    const srcLangSel = document.getElementById('src-lang');
    const tgtLangSel = document.getElementById('tgt-lang');

    // ========= Language codes (FLORES) ========= (unchanged)
    const FLORES = {
      "Assamese": "asm_Beng","Bengali": "ben_Beng","Bodo": "brx_Deva","Dogri": "doi_Deva","English": "eng_Latn",
      "Gujarati": "guj_Gujr","Hindi": "hin_Deva","Kannada": "kan_Knda","Kashmiri (Arabic)": "kas_Arab","Kashmiri (Devanagari)": "kas_Deva",
      "Konkani": "gom_Deva","Maithili": "mai_Deva","Malayalam": "mal_Mlym","Marathi": "mar_Deva","Manipuri (Bengali)": "mni_Beng",
      "Manipuri (Meitei)": "mni_Mtei","Nepali": "npi_Deva","Odia": "ory_Orya","Punjabi": "pan_Guru","Sanskrit": "san_Deva",
      "Santali (Ol Chiki)": "sat_Olck","Sindhi (Arabic)": "snd_Arab","Sindhi (Devanagari)": "snd_Deva","Tamil": "tam_Taml","Telugu": "tel_Telu","Urdu": "urd_Arab"
    };
    const HUMAN_BY_CODE = Object.fromEntries(Object.entries(FLORES).map(([k,v]) => [v,k]));

    function populateLanguageSelects() {
      const srcOptions = [{ label: 'Auto', value: 'auto' }, { label: 'English', value: 'eng_Latn' },
        ...Object.entries(FLORES).filter(([name]) => name !== 'English').map(([name, code]) => ({ label: name, value: code }))
      ];
      srcOptions.forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; srcLangSel.appendChild(opt); });

      const tgtOptions = [{ label: 'Same', value: 'same' }, { label: 'English', value: 'eng_Latn' },
        ...Object.entries(FLORES).filter(([name]) => name !== 'English').map(([name, code]) => ({ label: name, value: code }))
      ];
      tgtOptions.forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; tgtLangSel.appendChild(opt); });
    }
    populateLanguageSelects();

    // ========= Theme ========= (unchanged)
    function loadSettings() { try { const raw = localStorage.getItem(SETTINGS_KEY); return raw ? JSON.parse(raw) : {}; } catch { return {}; } }
    function saveSettings(settings) { try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); } catch {} }
    const settings = loadSettings();
    if (settings.theme === 'dark' || settings.theme === 'light') {
      document.documentElement.setAttribute('data-theme', settings.theme);
      themeToggle.setAttribute('aria-pressed', settings.theme === 'dark' ? 'true' : 'false');
    } else {
      const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const defaultTheme = systemPrefersDark ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', defaultTheme);
      themeToggle.setAttribute('aria-pressed', defaultTheme === 'dark' ? 'true' : 'false');
      settings.theme = defaultTheme; saveSettings(settings);
    }
    themeToggle.addEventListener('click', () => {
      const current = document.documentElement.getAttribute('data-theme') || 'dark';
      const next = current === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
      themeToggle.setAttribute('aria-pressed', next === 'dark' ? 'true' : 'false');
      settings.theme = next; saveSettings(settings);
      showBanner(`Theme: ${next} mode`, true); setTimeout(hideBanner, 1200);
    });

    // ========= Banners / status ========= (enhanced for CORS errors)
    function showBanner(msg, ok=false) { bannerEl.textContent = msg; bannerEl.classList.toggle('ok', !!ok); bannerEl.style.display = 'block'; }
    function hideBanner() { bannerEl.style.display = 'none'; bannerEl.textContent = ''; bannerEl.classList.remove('ok'); }
    function updateOnlineStatus() {
      if (!navigator.onLine) showBanner('Offline: messages will fail until connection is restored.');
      else { showBanner('Back online.', true); setTimeout(hideBanner, 1500); }
    }
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus();

    // ========= Storage helpers ========= (unchanged)
    function storageAvailable() { try { const x='__storage_test__'; localStorage.setItem(x,x); localStorage.removeItem(x); return true; } catch { return false; } }
    const HAS_STORAGE = storageAvailable();
    function safeSetItem(key, value) { if (!HAS_STORAGE) return false; try { localStorage.setItem(key, value); return true; } catch (err) { console.warn('Storage set failed:', err); return false; } }
    function safeGetItem(key) { if (!HAS_STORAGE) return null; try { return localStorage.getItem(key); } catch { return null; } }

    // ========= Data model ========= (unchanged)
    function uid() { return 'c' + Math.random().toString(36).slice(2, 10); }
    function loadConversations() {
      try { const raw = safeGetItem(STORAGE_KEY); const parsed = raw ? JSON.parse(raw) : []; return Array.isArray(parsed) ? parsed : []; }
      catch (e) { console.error('Failed to parse conversations from localStorage:', e); return []; }
    }
    let conversations = loadConversations();
    if (!Array.isArray(conversations)) conversations = [];
    let activeId = conversations.length ? conversations[0].id : null;

    function saveConversations() { try { safeSetItem(STORAGE_KEY, JSON.stringify(conversations)); } catch (e) { console.error('Failed to save conversations:', e); } }

    function createConversation() {
      const conv = { id: uid(), title: 'New Chat', messages: [] };
      conversations.unshift(conv);
      saveConversations();
      return conv;
    }
    function getActiveConversation() { return conversations.find(c => c.id === activeId) || null; }
    function ensureActiveConversation() {
      let conv = getActiveConversation();
      if (!conv) {
        conv = conversations.length ? conversations[0] : createConversation();
        activeId = conv.id; saveConversations();
      }
      return conv;
    }
    function deleteConversation(id) {
      const idx = conversations.findIndex(c => c.id === id);
      if (idx >= 0) conversations.splice(idx, 1);
      if (!conversations.length) { const conv = createConversation(); activeId = conv.id; }
      else { activeId = conversations[0].id; }
      saveConversations();
    }
    function updateTitleFromFirstUser(conv) {
      const first = conv.messages.find(m => m.sender === 'user');
      if (first) conv.title = first.text.slice(0, 40) + (first.text.length > 40 ? 'â€¦' : '');
    }

    // ========= Sync payload builder =========
    function buildMessagesPayload(conv) {
      const last = (conv.messages || []).slice(-12).map(m => ({
        role: m.sender === 'user' ? 'user' : 'assistant',
        content: String(m.text ?? '')
      }));
      return [{ role: 'system', content: systemPrompt }, ...last];
    }

    // ========= Markdown rendering ========= (unchanged)
    let md = null;
    function initMarked() {
      try {
        const MarkedClass = globalThis.marked?.Marked;
        const pluginFactory = globalThis.markedHighlight?.markedHighlight;
        if (MarkedClass) {
          md = pluginFactory
            ? new MarkedClass(pluginFactory({
                langPrefix: 'hljs language-',
                emptyLangClass: 'hljs',
                highlight(code, lang) {
                  const language = globalThis.hljs?.getLanguage(lang) ? lang : 'plaintext';
                  try { return globalThis.hljs.highlight(code, { language }).value; } catch { return code; }
                }
              }))
            : new MarkedClass();
          md.setOptions({ gfm: true, breaks: true });
        } else if (globalThis.marked?.parse) {
          md = globalThis.marked;
          md.setOptions?.({ gfm: true, breaks: true });
        }
      } catch (e) { console.warn('Marked init failed', e); }
    }
    window.addEventListener('load', () => { initMarked(); inputField?.focus?.(); });

    function sanitizeHTML(html) {
      try { if (window.DOMPurify?.sanitize) return window.DOMPurify.sanitize(html, { USE_PROFILES: { html: true } }); }
      catch (e) { console.warn('DOMPurify sanitize failed; falling back to text.', e); }
      const div = document.createElement('div'); div.textContent = html ?? ''; return div.innerHTML;
    }
    function renderMarkdownToHTML(markdown) {
      try {
        if (!md && globalThis.marked) initMarked();
        if (md) {
          const rawHTML = md.parse(String(markdown ?? ''));
          return sanitizeHTML(rawHTML);
        }
      } catch (e) { console.warn('Markdown render failed; falling back to text.', e); }
      const div = document.createElement('div'); div.textContent = String(markdown ?? ''); return div.innerHTML;
    }
    function openLinksSafely(container) {
      container.querySelectorAll('a[href]').forEach(a => {
        a.setAttribute('target', '_blank'); a.setAttribute('rel', 'noopener noreferrer');
      });
    }
    function enhanceCodeBlocks(root) {
      root.querySelectorAll('pre > code').forEach(code => {
        const pre = code.parentElement;
        const lang = [...code.classList].find(c => c.startsWith('language-'))?.slice(9) || 'text';
        const wrap = document.createElement('div'); wrap.className = 'code-wrap';
        const header = document.createElement('div'); header.className = 'code-header';
        const langEl = document.createElement('span'); langEl.className = 'lang'; langEl.textContent = lang.toUpperCase();
        const copy = document.createElement('button'); copy.className = 'copy-btn'; copy.type = 'button'; copy.textContent = 'Copy';
        copy.addEventListener('click', async () => {
          try { await navigator.clipboard.writeText(code.textContent || ''); showBanner('Copied to clipboard', true); setTimeout(hideBanner, 1000); }
          catch { showBanner('Copy failed'); }
        });
        header.appendChild(langEl); header.appendChild(copy);
        pre.replaceWith(wrap); wrap.appendChild(header); wrap.appendChild(pre);
        if (globalThis.hljs && !globalThis.markedHighlight) {
          try { globalThis.hljs.highlightElement(code); } catch {}
        }
      });
    }
    function scrollBottom() { chatContainer.scrollTop = chatContainer.scrollHeight; }

    // ========= Random utilities ========= (unchanged)
    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // ========= Starters (pool) ========= (unchanged)
    const START_CATEGORIES = {
      'Unity & Games': [
        'Write a Unity door interaction script with E/X/touch input.',
        'Fix overlapping colliders for a pickup system.',
        'Make a mobile FPS controller with smooth look.',
        'Create a shader for water with reflections.',
        'Design NPC dialogue with walking behavior.'
      ],
      'Web & JS': [
        'Build a page with animated route transitions.',
        'Create a debounce utility with tests.',
        'Optimize a scrollâ€‘based parallax without jank.',
        'Build a dark/light theme toggle with CSS vars.',
        'Animate a loader that respects reduced motion.'
      ],
      'Python & Streaming': [
        'Optimize Python socket streaming to hit 30+ FPS.',
        'Reduce latency with better chunking and compression.',
        'Add error correction for grainy/static frames.',
        'Profile bottlenecks in encode/decode pipeline.',
        'Implement a custom reliable UDP protocol.'
      ],
      'AI & LLM': [
        'Draft a prompt style guide for coding tasks.',
        'Explain GGUF quantization choices for 3B models.',
        'Design a fineâ€‘tuning script with LoRA adapters.',
        'Create evaluation prompts for coding tutors.',
        'Plan a retrieval pipeline for small devices.'
      ],
      'YouTube & Content': [
        'Outline a 5â€‘minute tutorial with hook and CTA.',
        'Write a thumbnail copy list with A/B variants.',
        'Draft a voiceover script with time stamps.',
        'Create a chapter structure from a transcript.',
        'Turn comments into FAQs with short answers.'
      ],
      'Translations (Indic)': [
        'Translate a Hindi paragraph to English.',
        'Localize a UI string set to Marathi.',
        'Backâ€‘translate to validate meaning in Tamil.',
        'Glossary: create consistent key terms.',
        'Detect mixedâ€‘script content and normalize.'
      ]
    };
    function generateStartersPool() {
      const pool = [];
      Object.values(START_CATEGORIES).forEach(arr => arr.forEach(s => pool.push(s)));
      const actions = ['Explain', 'Refactor', 'Summarize', 'Benchmark', 'Compare', 'Document'];
      const subjects = ['this code', 'this error', 'this design', 'this script', 'this idea'];
      actions.forEach(a => subjects.forEach(su => pool.push(`${a} ${su}.`)));
      return shuffleInPlace(pool);
    }
    let STARTERS_POOL = generateStartersPool();

    // ========= Waiting widget ========= (unchanged)
    let waitingNode = null;
    let tipsTimer = null;
    const TIPS = [
      'Tip: Press Enter to send and Shift+Enter for a new line.',
      'Pro: Paste code â€” it autoâ€‘highlights.',
      'Hint: Set Input/Reply languages to translate.',
      'Try: Ask for an outline first, then expand.'
    ];
    function showWaitingWidget() {
      hideWaitingWidget();
      const wrapper = document.createElement('div');
      wrapper.className = 'message bot waiting-card';
      wrapper.setAttribute('role', 'status');
      wrapper.setAttribute('aria-live', 'polite');
      wrapper.setAttribute('aria-atomic', 'true');

      const content = document.createElement('div'); content.className = 'content';
      const row = document.createElement('div'); row.className = 'waiting-row';
      const bubble = document.createElement('div'); bubble.className = 'typing-bubble';
      for (let i = 0; i < 3; i++) { const d = document.createElement('div'); d.className = 'typing-dot'; bubble.appendChild(d); }
      const label = document.createElement('div'); label.textContent = 'Thinkingâ€¦';
      row.appendChild(bubble); row.appendChild(label);

      const sub = document.createElement('div'); sub.className = 'waiting-subtle'; sub.textContent = TIPS[0];

      const chips = document.createElement('div'); chips.className = 'suggestion-row';
      shuffleInPlace([...STARTERS_POOL]).slice(0, 4).forEach(s => {
        const b = document.createElement('button'); b.type = 'button'; b.className = 'suggestion-chip'; b.textContent = s;
        b.onclick = () => { inputField.value = s; inputField.focus(); };
        chips.appendChild(b);
      });

      const skelWrap = document.createElement('div'); skelWrap.style.marginTop = '10px';
      for (let i = 0; i < 2; i++) { const line = document.createElement('div'); line.className = 'skeleton skel-line'; line.style.width = i === 0 ? '65%' : '48%'; skelWrap.appendChild(line); }

      content.appendChild(row); content.appendChild(sub); content.appendChild(chips); content.appendChild(skelWrap);
      wrapper.appendChild(content);
      chatContainer.appendChild(wrapper);
      scrollBottom();

      let idx = 0; tipsTimer = setInterval(() => { idx = (idx + 1) % TIPS.length; sub.textContent = TIPS[idx]; }, 3500);
      waitingNode = wrapper;
    }
    function hideWaitingWidget() { if (tipsTimer) clearInterval(tipsTimer); tipsTimer = null; if (waitingNode?.parentNode) waitingNode.parentNode.removeChild(waitingNode); waitingNode = null; }

    // ========= Rendering ========= (unchanged)
    function renderChatList() {
      chatListEl.innerHTML = '';
      conversations.forEach(c => {
        const item = document.createElement('div');
        item.className = 'chat-item' + (c.id === activeId ? ' active' : '');
        const dot = document.createElement('div'); dot.className = 'dot';
        const title = document.createElement('div'); title.className = 'title'; title.textContent = c.title || 'New Chat';
        item.appendChild(dot); item.appendChild(title);
        item.onclick = () => { activeId = c.id; renderChatList(); renderActiveConversation(); };
        chatListEl.appendChild(item);
      });
    }

    function addMessageToDOM(message) {
      const wrapper = document.createElement('div'); wrapper.classList.add('message', message.sender);
      const content = document.createElement('div'); content.className = 'content';
      if (message.sender === 'bot' && typeof message.text === 'string') {
        const clean = renderMarkdownToHTML(message.text);
        const temp = document.createElement('div'); temp.innerHTML = clean;
        openLinksSafely(temp); enhanceCodeBlocks(temp);
        content.replaceChildren(...temp.childNodes);
      } else { content.textContent = message.text ?? ''; }
      wrapper.appendChild(content);
      const tools = document.createElement('div'); tools.className = 'msg-tools';
      const copyBtn = document.createElement('button'); copyBtn.className = 'chip-btn'; copyBtn.textContent = 'Copy';
      copyBtn.onclick = async () => {
        try { const plain = content.textContent || ''; await navigator.clipboard.writeText(plain); showBanner('Copied to clipboard', true); setTimeout(hideBanner, 1000); }
        catch { showBanner('Copy failed'); }
      };
      tools.appendChild(copyBtn);
      const meta = document.createElement('div'); meta.className = 'msg-meta'; meta.textContent = message.meta || '';
      wrapper.appendChild(tools); wrapper.appendChild(meta);
      chatContainer.appendChild(wrapper);
    }

    function renderEmptyState() {
      emptyChips.innerHTML = '';
      emptyState.hidden = false;
      const count = Math.random() < 0.5 ? 2 : 4;
      const picks = shuffleInPlace([...STARTERS_POOL]).slice(0, count);
      picks.forEach(txt => {
        const btn = document.createElement('button'); btn.type = 'button'; btn.className = 'suggestion-chip'; btn.textContent = txt;
        btn.onclick = () => { inputField.value = txt; inputField.focus(); };
        emptyChips.appendChild(btn);
      });
    }

    function renderActiveConversation() {
      hideBanner();
      const conv = ensureActiveConversation();
      chatTitleEl.textContent = conv?.title || 'New Chat';
      chatContainer.innerHTML = '';
      emptyState.hidden = true;

      if (!conv?.messages?.length) {
        renderEmptyState();
      } else {
        (conv.messages || []).forEach(addMessageToDOM);
      }
      scrollBottom();
    }

    // ========= Initial UI ========= (unchanged)
    ensureActiveConversation();
    renderChatList(); renderActiveConversation();

    // New / Delete chat buttons (unchanged)
    newChatBtn.addEventListener('click', () => {
      const conv = createConversation(); activeId = conv.id; renderChatList(); renderActiveConversation(); inputField.focus();
    });
    delChatBtn.addEventListener('click', () => {
      if (!activeId) return;
      if (confirm('Delete this chat?')) { deleteConversation(activeId); renderChatList(); renderActiveConversation(); }
    });

    // Input: Enter to send (unchanged)
    inputField.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (typeof inputForm.requestSubmit === 'function') inputForm.requestSubmit();
        else inputForm.submit();
      }
    });

    // ========= Networking ========= (enhanced for CORS detection)
    let inFlightController = null;
    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
    function backoffDelay(attempt) { const base = Math.min(BACKOFF_BASE_MS * (2 ** attempt), BACKOFF_CAP_MS); const jitter = Math.random() * 200; return base + jitter; }
    stopButton.addEventListener('click', () => {
      if (inFlightController) { inFlightController.abort(); showBanner('Request canceled.', true); }
      hideWaitingWidget();
    });

    async function readOpenAIStream(res, onDelta) {
      const reader = res.body.getReader(); const decoder = new TextDecoder();
      let buffer = ''; let content = '';
      while (true) {
        const { done, value } = await reader.read(); if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n'); buffer = lines.pop() || '';
        for (const line of lines) {
          const l = line.trim(); if (!l || l.startsWith(':')) continue; if (l === 'data: [DONE]') return content;
          if (l.startsWith('data: ')) {
            try { const json = JSON.parse(l.slice(6)); const delta = json?.choices?.[0]?.delta?.content ?? ''; if (delta) { content += delta; if (onDelta) onDelta(delta); } } catch {}
          }
        }
      }
      return content;
    }

    class RetryableError extends Error { constructor(message, status) { super(message); this.status = status; } }

    async function chatRequest(payload, onDelta) {
      // Validate payload before send
      if (!payload.messages || !Array.isArray(payload.messages) || payload.messages.length === 0) {
        console.error('Invalid payload - missing or empty messages:', payload);
        throw new Error('Payload construction failed: missing messages');
      }
      if (DEBUG_PAYLOAD) console.log('Sending payload:', JSON.stringify(payload, null, 2));

      let attempt = 0; let lastError = null; const t0 = performance.now();
      while (attempt <= MAX_RETRIES) {
        const controller = new AbortController(); inFlightController = controller;
        const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
        try {
          const headers = {
            'Content-Type': 'application/json',
            'Accept': USE_STREAM ? 'text/event-stream, application/json;q=0.9' : 'application/json'
          };
          if (apiKey) headers['Authorization'] = `Bearer ${apiKey}`;
          const res = await fetch(apiUrl, { 
            method: 'POST', 
            headers, 
            body: JSON.stringify(payload), 
            signal: controller.signal 
          });
          clearTimeout(timeoutId);
          if (!res.ok) {
            const errText = await res.text();
            console.error('API error response:', errText);
            const data = JSON.parse(errText || '{}');
            const status = res.status; const errMsg = data?.error?.message || `HTTP ${status}: ${res.statusText}`;
            if (status === 429 || (status >= 500 && status < 600)) throw new RetryableError(errMsg, status);
            throw new Error(errMsg);
          }
          const ctype = (res.headers.get('content-type') || '').toLowerCase();
          if (USE_STREAM && ctype.includes('text/event-stream')) {
            const s = await readOpenAIStream(res, onDelta); const t1 = performance.now(); latencyChip.textContent = `${Math.round(t1 - t0)} ms`; inFlightController = null; return { choices: [{ message: { content: s } }] };
          }
          const text = await res.text(); let data; try { data = JSON.parse(text); } catch { console.error('Raw response (not JSON):', text); throw new Error('Invalid JSON response from server.'); }
          const t1 = performance.now(); latencyChip.textContent = `${Math.round(t1 - t0)} ms`; inFlightController = null; return data;
        } catch (err) {
          clearTimeout(timeoutId); lastError = err;
          const isAbort = err?.name === 'AbortError' || err?.message?.includes('aborted'); if (isAbort) throw err;
          const status = err?.status;
          const isCORS = err.message.includes('CORS') || err.name === 'TypeError'; // Detect CORS/fetch blocks
          if (isCORS) {
            showBanner(`CORS error: Configure server to allow origin ${location.origin}. Use local LM Studio.`, false);
            throw new Error('CORS blocked request. Serve via HTTP and fix backend headers.');
          }
          const retryable = err instanceof RetryableError || status === 429 || (status >= 500 && status < 600) || !status;
          if (retryable && attempt < MAX_RETRIES) { const wait = backoffDelay(attempt); showBanner(`Retryingâ€¦ attempt ${attempt + 2}/${MAX_RETRIES + 1} in ${Math.round(wait)}ms`); await sleep(wait); attempt++; continue; }
          throw err;
        } finally { inFlightController = null; }
      }
      throw lastError || new Error('Unknown error');
    }

    // ========= Local translator ========= (unchanged, but with local base)
    async function translateLocal(text, srcFlores, tgtFlores, num_beams = 3, max_length = 256) {
      if (!text || srcFlores === tgtFlores) return text;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), TRANS_TIMEOUT_MS);
      const body = { text, src_lang: srcFlores, tgt_lang: tgtFlores, num_beams, max_length };
      try {
        const res = await fetch(`${TRANS_BASE}/translate`, { 
          method: 'POST', 
          headers: { 'Content-Type': 'application/json' }, 
          body: JSON.stringify(body),
          signal: controller.signal 
        });
        clearTimeout(timeoutId);
        if (!res.ok) throw new Error(`Translator failed (${res.status})`);
        const data = await res.json().catch(() => ({}));
        let out = data?.translations;
        if (Array.isArray(out)) {
          out = out.length > 0 ? out[0] : null;
        }
        return out || text;
      } catch (err) {
        clearTimeout(timeoutId);
        if (err.name === 'AbortError') {
          console.warn('Translation timed out after', TRANS_TIMEOUT_MS, 'ms');
        } else {
          console.warn('Translation failed:', err);
        }
        return text; // Fallback
      }
    }

    function toText(v) {
      if (Array.isArray(v)) return v.join(' ');
      if (v == null) return '';
      return String(v);
    }

    function guessFloresByScript(text) {
      const ranges = [
        { re: /[\u0900-\u097F]/, code: 'hin_Deva' },{ re: /[\u0980-\u09FF]/, code: 'ben_Beng' },{ re: /[\u0A00-\u0A7F]/, code: 'pan_Guru' },{ re: /[\u0A80-\u0AFF]/, code: 'guj_Gujr' },
        { re: /[\u0B00-\u0B7F]/, code: 'ory_Orya' },{ re: /[\u0B80-\u0BFF]/, code: 'tam_Taml' },{ re: /[\u0C00-\u0C7F]/, code: 'tel_Telu' },{ re: /[\u0C80-\u0CFF]/, code: 'kan_Knda' },
        { re: /[\u0D00-\u0D7F]/, code: 'mal_Mlym' },{ re: /[\u0600-\u06FF]/, code: 'urd_Arab' },{ re: /[\u1C50-\u1C7F]/, code: 'mni_Mtei' },{ re: /[\u1C00-\u1C4F]/, code: 'sat_Olck' },
      ];
      for (const r of ranges) if (r.re.test(text)) return r.code;
      return 'eng_Latn';
    }

    // ========= Submit handler ========= (simplified translation)
    const inputFormEl = document.getElementById('input-form');
    inputFormEl.addEventListener('submit', async (e) => {
      e.preventDefault(); hideBanner();

      const userMessage = inputField.value.trim(); if (!userMessage) return;

      let conv = ensureActiveConversation();
      emptyState.hidden = true;

      const userChat = { sender: 'user', text: userMessage, meta: new Date().toLocaleTimeString() };
      conv.messages.push(userChat);
      if (conv.title === 'New Chat') updateTitleFromFirstUser(conv);
      saveConversations(); renderChatList();
      addMessageToDOM(userChat);

      inputField.value = ''; inputField.focus();
      sendButton.disabled = true; stopButton.style.display = 'inline-block';
      showWaitingWidget();

      try {
        let srcFlores = srcLangSel.value === 'auto' ? guessFloresByScript(userMessage) : srcLangSel.value;
        let outFlores = tgtLangSel.value === 'same' ? srcFlores : tgtLangSel.value;

        const userInEnglishRaw = (srcFlores === 'eng_Latn') ? userMessage : await translateLocal(userMessage, srcFlores, 'eng_Latn');
        const userInEnglish = toText(userInEnglishRaw);

        let payload = { model: modelName, stream: false, messages: buildMessagesPayload(conv) };
        // Override only the last user message with English
        for (let i = payload.messages.length - 1; i >= 0; i--) {
          if (payload.messages[i].role === 'user') {
            payload.messages[i] = { role: 'user', content: userInEnglish };
            break;
          }
        }

        const t0 = performance.now();
        const data = await chatRequest(payload);
        const t1 = performance.now(); latencyChip.textContent = `${Math.round(t1 - t0)} ms`;

        const replyEn = toText(data?.choices?.[0]?.message?.content ?? '');

        const replyOutRaw = (outFlores === 'eng_Latn') ? replyEn : await translateLocal(replyEn, 'eng_Latn', outFlores);
        const replyOut = toText(replyOutRaw);

        const botMessage = { sender: 'bot', text: replyOut, meta: new Date().toLocaleTimeString() };
        addMessageToDOM(botMessage);
        conv.messages.push(botMessage); saveConversations(); scrollBottom();
        showBanner('Done', true); setTimeout(hideBanner, 700);
      } catch (err) {
        console.error('Chat error:', err);
        const errMsg = err.message.includes('CORS') ? 'CORS error: Fix server headers or use local API.' : err.message;
        const errorMessage = { sender: 'bot', text: `Error: ${errMsg}`, meta: new Date().toLocaleTimeString() };
        conv.messages.push(errorMessage); addMessageToDOM(errorMessage); saveConversations();
        showBanner(`Send failed: ${errMsg}`);
      } finally {
        hideWaitingWidget();
        sendButton.disabled = false; stopButton.style.display = 'none'; inputField.focus();
      }
    });
  </script>
</body>
</html>

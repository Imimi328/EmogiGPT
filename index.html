<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emogi Chatbot</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'/>">

  <!-- Marked UMD + marked-highlight UMD -->
  <script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>

  <!-- highlight.js + style -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css" />

  <!-- DOMPurify (sanitize rendered HTML) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>

<style>
  :root {
    --background-gradient: linear-gradient(180deg, rgba(0, 0, 0, 0.9), rgba(32, 32, 32, 0.7));
    --bg: #000000; --bg-elev: #000000; --bg-elev-2: #000000; --text: #e6e6ea;
    --muted: #a6adbb; --border: #2a2a22; --accent: #D4AF37; /* metallic gold */
    --accent-2: #FFD700; /* CSS gold */
    --danger: #ff6b6b; --ok: #2ecc71; --chip: #1a1f2a; --code-bg: #000000;
    --shadow: 0 6px 20px rgba(0,0,0,0.35);
    --bot-gradient: linear-gradient(180deg, rgba(25,25,25,0.96), rgba(0, 0, 0, 0.78));
  }

  html[data-theme="dark"] {
    color-scheme: dark;
    --bg: #000000; --bg-elev: #000000; --bg-elev-2: #0a0600; --text: #e6e6ea;
    --muted: #a6adbb; --border: #2a2a22; --accent: #D4AF37; --accent-2: #FFD700;
    --danger: #ff6b6b; --ok: #2ecc71; --chip: #1a1f2a; --code-bg: #0b0f17;
    --shadow: 0 6px 20px rgba(0,0,0,0.35);
    --bot-gradient: linear-gradient(180deg, rgba(25,25,25,0.96), rgba(0,0,0,0.78));
  }

  html[data-theme="light"] {
    color-scheme: light;
    --bg: #f7f8fa; --bg-elev: #ffffff; --bg-elev-2: #f2f4f8; --text: #111111;
    --muted: #545b66; --border: #e3e6ee; --accent: #beceff; /* royal blue */
    --accent-2: #afc5ff; /* deeper royal blue */
    --danger: #dc3545; --ok: #198754; --chip: #eef2fb; --code-bg: #f7f9ff;
    --shadow: 0 6px 20px rgba(0,0,0,0.08);
    --bot-gradient: linear-gradient(180deg, rgba(230,235,250,0.9), rgba(205,215,245,0.7));
  }

  html[data-theme="light"] {
    --accent: #D4AF37;   
    --accent-2: #B8860B;
  }
  

  * { box-sizing: border-box; }

  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:
      radial-gradient(1200px 800px at 80% -10%, rgba(212,175,55,0.10), transparent 60%),
      radial-gradient(800px 600px at -10% 110%, rgba(255,215,0,0.10), transparent 60%),
      var(--bg);
    display: flex; height: 100vh; color: var(--text);
  }

  html[data-theme="light"] body {
    background:
      radial-gradient(1200px 800px at 80% -10%, rgba(65,105,225,0.10), transparent 60%),
      radial-gradient(800px 600px at -10% 110%, rgba(43,87,199,0.08), transparent 60%),
      var(--bg);
  }

  aside {
    width: 280px; background: linear-gradient(180deg, var(--bg-elev), var(--bg-elev-2));
    border-right: 1px solid var(--border); display: flex; flex-direction: column;
  }

  .sidebar-header { padding: 12px; display: flex; gap: 8px; align-items: center; }
  .brand { font-weight: 700; letter-spacing: 0.3px; color: var(--muted); margin-left: auto; opacity: 0.9; }

  .btn {
    padding: 8px 10px; border: 1px solid var(--border); background: var(--chip); color: var(--text);
    border-radius: 8px; cursor: pointer; transition: transform .05s ease, background .15s ease;
  }
  .btn:hover { background: var(--bg-elev-2); }
  .btn:active { transform: translateY(1px); }

  .chat-list { flex: 1; overflow-y: auto; padding: 8px 10px; }

  .chat-item {
    padding: 10px; border-radius: 10px; margin-bottom: 8px; cursor: pointer;
    background: var(--chip); border: 1px solid transparent; display: flex; align-items: center; gap: 8px;
  }
  .chat-item .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent); opacity: 0.85; }
  .chat-item.active { background: linear-gradient(180deg, var(--bg-elev-2), var(--chip)); border: 1px solid var(--border); }
  .chat-item .title { font-size: 0.95em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text); }

  .sidebar-footer { padding: 10px; font-size: 0.85em; color: var(--muted); border-top: 1px solid var(--border); }
  main { flex: 1; display: flex; flex-direction: column; }

  header {
    background: linear-gradient(180deg, var(--bg-elev), var(--bg-elev-2)); color: var(--text);
    padding: 12px; font-size: 1.05em; font-weight: 700; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between; gap: 8px;
  }

  .header-title { flex: 1; text-align: center; }
  .header-actions { display: flex; gap: 8px; align-items: center; }

  #banner {
    display:none; background: rgba(255,107,107,0.10); color: var(--text);
    padding: 8px 12px; border-bottom: 1px solid var(--border); font-size: 0.95em;
  }
  #banner.ok { background: rgba(46,204,113,0.12); }

  #chat-container { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 12px; }

  .message {
    max-width: 72%; padding: 12px 16px; border-radius: 14px; word-wrap: break-word;
    box-shadow: var(--shadow); border: 1px solid var(--border); line-height: 1.45;
  }

  /* Theme-specific user bubble tints */
  html[data-theme="dark"] .user {
    background: linear-gradient(180deg, rgba(212,175,55,0.18), rgba(212,175,55,0.12));
    color: var(--text); align-self: flex-end; border-bottom-right-radius: 6px;
  }
  html[data-theme="light"] .user {
    background: linear-gradient(180deg, rgba(65,105,225,0.16), rgba(65,105,225,0.10));
    color: var(--text); align-self: flex-end; border-bottom-right-radius: 6px;
  }

  .bot { background: var(--bot-gradient); color: var(--text); align-self: flex-start; border-bottom-left-radius: 6px; }

  .content :is(h1,h2,h3) { margin: 0.2em 0 0.4em; }
  .content h1 { font-size: 1.2em; }
  .content h2 { font-size: 1.1em; }
  .content h3 { font-size: 1.0em; }
  .content p { margin: 0.6em 0; }
  .content ul, .content ol { padding-left: 1.2em; margin: 0.5em 0; }
  .content code { background: var(--code-bg); padding: 0.15em 0.35em; border-radius: 4px; }
  .content pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 0; overflow: auto; padding: 12px; margin: 0; }

  .msg-meta { font-size: 0.75em; color: var(--muted); margin-top: 8px; }
  .msg-tools { display: flex; gap: 6px; margin-top: 8px; }
  .chip-btn { border: 1px solid var(--border); background: var(--chip); color: var(--muted); padding: 4px 8px; border-radius: 6px; cursor: pointer; }
  .chip-btn:hover { color: var(--text); }

  .code-wrap { border: 1px solid var(--border); border-radius: 10px; overflow: hidden; background: var(--code-bg); }
  .code-header { display:flex; align-items:center; justify-content:space-between; padding:6px 10px; font-size:12px; color: var(--muted); background: var(--bg-elev-2); border-bottom:1px solid var(--border); }
  .code-header .lang { letter-spacing: .3px; }
  .copy-btn { border: 1px solid var(--border); background: var(--chip); color: var(--muted); padding: 4px 8px; border-radius: 6px; cursor: pointer; }
  .copy-btn:hover { color: var(--text); }

  form { display: flex; padding: 12px; background: var(--bg-elev); border-top: 1px solid var(--border); gap: 10px; }
  #input { flex: 1; padding: 12px; border: 1px solid var(--border); border-radius: 10px; font-size: 1em; background: var(--bg-elev-2); color: var(--text); }

  #send, #stop { padding: 10px 16px; background: var(--accent); border: none; color: #fff; border-radius: 10px; cursor: pointer; font-size: 1em; }
  #stop { background: var(--danger); display: none; }
  #send:disabled { background: #666; cursor: not-allowed; }

  .skeleton {
    background: linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.10), rgba(255,255,255,0.06));
    background-size: 200% 100%; animation: shimmer 1.2s infinite; width: 180px; height: 18px; border-radius: 6px; margin: 4px 0;
  }
  @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }

  /* Typing indicator bubble */
  .typing-bubble {
    display: inline-flex; align-items: center; gap: 6px;
    padding: 10px 12px; border-radius: 999px;
    background: var(--bg-elev-2); border: 1px solid var(--border); box-shadow: var(--shadow);
  }
  .typing-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--muted); opacity: 0.2;
    animation: typingPulse 1s infinite ease-in-out;
  }
  .typing-dot:nth-child(2) { animation-delay: .15s; }
  .typing-dot:nth-child(3) { animation-delay: .3s; }
  @keyframes typingPulse {
    0%, 80%, 100% { transform: translateY(0); opacity: 0.2; }
    40% { transform: translateY(-4px); opacity: 0.9; }
  }

  .waiting-card.message.bot { position: relative; background: var(--bot-gradient); border: 1px solid var(--border); border-bottom-left-radius: 6px; box-shadow: var(--shadow); }
  .waiting-row { display: flex; align-items: center; gap: 10px; }
  .waiting-subtle { color: var(--muted); font-size: 0.9em; margin-top: 6px; }

  .suggestion-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
  .suggestion-chip {
    border: 1px solid var(--border); background: var(--chip); color: var(--muted);
    padding: 6px 10px; border-radius: 999px; cursor: pointer; font-size: 0.9em;
  }
  .suggestion-chip:hover { color: var(--text); background: var(--bg-elev-2); }

  .skel-line { width: 70%; height: 12px; border-radius: 6px; }

  /* Empty state */
  .empty-state {
    max-width: 920px; margin: 40px auto; padding: 20px;
    background: linear-gradient(180deg, var(--bg-elev), var(--bg-elev-2));
    border: 1px solid var(--border); border-radius: 16px; box-shadow: var(--shadow);
    text-align: center;
  }
  .empty-title { font-size: 1.1em; margin-bottom: 6px; }
  .empty-sub { color: var(--muted); }
  .empty-chips { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 10px; justify-content: center; margin-top: 14px; }

  .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }

  @media (prefers-reduced-motion: reduce) {
    .skeleton { animation: none; }
    .typing-dot { animation: none; opacity: 0.4; }
    .btn, .chat-item, .suggestion-chip { transition: none !important; }
    html, body { scroll-behavior: auto; }
  }

  *::-webkit-scrollbar { width: 10px; height: 10px; }
  *::-webkit-scrollbar-thumb { background: var(--border); border-radius: 10px; }
  *::-webkit-scrollbar-thumb:hover { background: #3a4256; }

  @media (max-width: 900px) {
    aside { width: 74px; }
    .brand { display: none; }
    .chat-item .title { display: none; }
    .chat-item .dot { margin: 0 auto; }
    .message { max-width: 92%; }
    header { font-size: 1em; }
    .lang-selects { display: none; }
  }
</style>

</head>
<body>
  <aside>
    <div class="sidebar-header">
      <button id="new-chat" class="btn" title="Start new chat">+ New</button>
      <button id="delete-chat" class="btn" title="Delete current chat">ðŸ—‘</button>
      <span class="brand">Emogi</span>
    </div>
    <div id="chat-list" class="chat-list"></div>
    <div class="sidebar-footer">Emogi Chatbot</div>
  </aside>

  <main>
    <header>
      <div class="header-actions">
        <button id="theme-toggle" class="btn" title="Toggle theme" aria-pressed="false">ðŸŒ“</button>
      </div>
      <div id="chat-title" class="header-title">New Chat</div>
      <div class="header-actions">
        <div class="lang-selects" style="display:flex; gap:6px; align-items:center;">
          <label for="src-lang" style="font-size:.85em; color:var(--muted);">Input</label>
          <select id="src-lang" class="btn" style="padding:8px;">
            <option value="auto">Auto</option>
          </select>
          <label for="tgt-lang" style="font-size:.85em; color:var(--muted);">Reply</label>
          <select id="tgt-lang" class="btn" style="padding:8px;">
            <option value="same">Same</option>
          </select>
        </div>
        <span id="latency-chip" class="btn" title="Last response time" style="opacity:.8; cursor:default;">â€“ ms</span>
      </div>
    </header>

    <div id="banner" role="status" aria-live="polite" aria-atomic="true"></div>

    <div id="chat-container"></div>

    <section id="empty-state" class="empty-state" hidden>
      <div class="empty-title">Start a conversation</div>
      <div class="empty-sub">Ask for code help, translations, summaries, or ideas.</div>
      <div class="empty-chips" id="empty-chips"></div>
    </section>

    <form id="input-form" novalidate>
      <input type="text" id="input" placeholder="Type a message..." autocomplete="off" required enterkeyhint="send" />
      <button type="button" id="stop" title="Cancel inâ€‘flight request">Stop</button>
      <button type="submit" id="send">Send</button>
    </form>
  </main>

  <script>
    // ========= Config =========
    const apiUrl = 'https://api.emogi.space/v1/chat/completions';
    const modelName = 'emogi/emogi/emogigptv1.ggufs';
    const apiKey = ''; // optional

    const TRANS_BASE = 'https://transapi.emogi.space';
    const USE_STREAM = false;

    const systemPrompt =
      'You are a helpful AI model developed by Ritesh Verma, the CEO of Team Emogi. Your primary role is to assist with programming, video editing, AI, game development, and creative tasks. You represent Team Emogi, a multi-level organization working in AR/VR, AI, animation, space, and game development. Be formal and informative in your tone.';

    const STORAGE_KEY = 'emogiConversationsV7';
    const SETTINGS_KEY = 'emogiSettingsV1';

    const TIMEOUT_MS = 180000;
    const MAX_RETRIES = 3;
    const BACKOFF_BASE_MS = 600;
    const BACKOFF_CAP_MS = 8000;

    if (location.protocol === 'file:') {
      console.warn('Running from file:// may cause CORS issues for cross-origin APIs.');
      const banner = document.getElementById('banner');
      banner.textContent = 'Open this file via http(s) (e.g., http://localhost) to avoid CORS origin "null".';
      banner.style.display = 'block';
    }

    // ========= DOM =========
    const chatListEl = document.getElementById('chat-list');
    const newChatBtn = document.getElementById('new-chat');
    const delChatBtn = document.getElementById('delete-chat');
    const chatTitleEl = document.getElementById('chat-title');
    const bannerEl = document.getElementById('banner');
    const chatContainer = document.getElementById('chat-container');
    const emptyState = document.getElementById('empty-state');
    const emptyChips = document.getElementById('empty-chips');
    const inputForm = document.getElementById('input-form');
    const inputField = document.getElementById('input');
    const sendButton = document.getElementById('send');
    const stopButton = document.getElementById('stop');
    const themeToggle = document.getElementById('theme-toggle');
    const latencyChip = document.getElementById('latency-chip');
    const srcLangSel = document.getElementById('src-lang');
    const tgtLangSel = document.getElementById('tgt-lang');

    // ========= Language codes (FLORES) =========
    const FLORES = {
      "Assamese": "asm_Beng","Bengali": "ben_Beng","Bodo": "brx_Deva","Dogri": "doi_Deva","English": "eng_Latn",
      "Gujarati": "guj_Gujr","Hindi": "hin_Deva","Kannada": "kan_Knda","Kashmiri (Arabic)": "kas_Arab","Kashmiri (Devanagari)": "kas_Deva",
      "Konkani": "gom_Deva","Maithili": "mai_Deva","Malayalam": "mal_Mlym","Marathi": "mar_Deva","Manipuri (Bengali)": "mni_Beng",
      "Manipuri (Meitei)": "mni_Mtei","Nepali": "npi_Deva","Odia": "ory_Orya","Punjabi": "pan_Guru","Sanskrit": "san_Deva",
      "Santali (Ol Chiki)": "sat_Olck","Sindhi (Arabic)": "snd_Arab","Sindhi (Devanagari)": "snd_Deva","Tamil": "tam_Taml","Telugu": "tel_Telu","Urdu": "urd_Arab"
    };
    const HUMAN_BY_CODE = Object.fromEntries(Object.entries(FLORES).map(([k,v]) => [v,k]));

    function populateLanguageSelects() {
      const srcOptions = [{ label: 'Auto', value: 'auto' }, { label: 'English', value: 'eng_Latn' },
        ...Object.entries(FLORES).filter(([name]) => name !== 'English').map(([name, code]) => ({ label: name, value: code }))
      ];
      srcOptions.forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; srcLangSel.appendChild(opt); });

      const tgtOptions = [{ label: 'Same', value: 'same' }, { label: 'English', value: 'eng_Latn' },
        ...Object.entries(FLORES).filter(([name]) => name !== 'English').map(([name, code]) => ({ label: name, value: code }))
      ];
      tgtOptions.forEach(o => { const opt = document.createElement('option'); opt.value = o.value; opt.textContent = o.label; tgtLangSel.appendChild(opt); });
    }
    populateLanguageSelects();

    // ========= Theme =========
    function loadSettings() { try { const raw = localStorage.getItem(SETTINGS_KEY); return raw ? JSON.parse(raw) : {}; } catch { return {}; } }
    function saveSettings(settings) { try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); } catch {} }
    const settings = loadSettings();
    if (settings.theme === 'dark' || settings.theme === 'light') {
      document.documentElement.setAttribute('data-theme', settings.theme);
      themeToggle.setAttribute('aria-pressed', settings.theme === 'dark' ? 'true' : 'false');
    } else {
      const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const defaultTheme = systemPrefersDark ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', defaultTheme);
      themeToggle.setAttribute('aria-pressed', defaultTheme === 'dark' ? 'true' : 'false');
      settings.theme = defaultTheme; saveSettings(settings);
    }
    themeToggle.addEventListener('click', () => {
      const current = document.documentElement.getAttribute('data-theme') || 'dark';
      const next = current === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
      themeToggle.setAttribute('aria-pressed', next === 'dark' ? 'true' : 'false');
      settings.theme = next; saveSettings(settings);
      showBanner(`Theme: ${next} mode`, true); setTimeout(hideBanner, 1200);
    });

    // ========= Banners / status =========
    function showBanner(msg, ok=false) { bannerEl.textContent = msg; bannerEl.classList.toggle('ok', !!ok); bannerEl.style.display = 'block'; }
    function hideBanner() { bannerEl.style.display = 'none'; bannerEl.textContent = ''; bannerEl.classList.remove('ok'); }
    function updateOnlineStatus() {
      if (!navigator.onLine) showBanner('Offline: messages will fail until connection is restored.');
      else { showBanner('Back online.', true); setTimeout(hideBanner, 1500); }
    }
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus();

    // ========= Storage helpers =========
    function storageAvailable() { try { const x='__storage_test__'; localStorage.setItem(x,x); localStorage.removeItem(x); return true; } catch { return false; } }
    const HAS_STORAGE = storageAvailable();
    function safeSetItem(key, value) { if (!HAS_STORAGE) return false; try { localStorage.setItem(key, value); return true; } catch (err) { console.warn('Storage set failed:', err); return false; } }
    function safeGetItem(key) { if (!HAS_STORAGE) return null; try { return localStorage.getItem(key); } catch { return null; } }

    // ========= Data model =========
    function uid() { return 'c' + Math.random().toString(36).slice(2, 10); }
    function loadConversations() {
      try { const raw = safeGetItem(STORAGE_KEY); const parsed = raw ? JSON.parse(raw) : []; return Array.isArray(parsed) ? parsed : []; }
      catch (e) { console.error('Failed to parse conversations from localStorage:', e); return []; }
    }
    let conversations = loadConversations();
    if (!Array.isArray(conversations)) conversations = [];
    let activeId = conversations.length ? conversations[0].id : null;

    function saveConversations() { try { safeSetItem(STORAGE_KEY, JSON.stringify(conversations)); } catch (e) { console.error('Failed to save conversations:', e); } }

    function createConversation() {
      const conv = { id: uid(), title: 'New Chat', messages: [] };
      conversations.unshift(conv);
      saveConversations();
      return conv;
    }
    function getActiveConversation() { return conversations.find(c => c.id === activeId) || null; }
    function ensureActiveConversation() {
      let conv = getActiveConversation();
      if (!conv) {
        conv = conversations.length ? conversations[0] : createConversation();
        activeId = conv.id; saveConversations();
      }
      return conv;
    }
    function deleteConversation(id) {
      const idx = conversations.findIndex(c => c.id === id);
      if (idx >= 0) conversations.splice(idx, 1);
      if (!conversations.length) { const conv = createConversation(); activeId = conv.id; }
      else { activeId = conversations[0].id; }
      saveConversations();
    }
    function updateTitleFromFirstUser(conv) {
      const first = conv.messages.find(m => m.sender === 'user');
      if (first) conv.title = first.text.slice(0, 40) + (first.text.length > 40 ? 'â€¦' : '');
    }
    function buildMessagesPayload(conv) {
      const last = (conv.messages || []).slice(-12).map(m => ({
        role: m.sender === 'user' ? 'user' : 'assistant',
        content: String(m.text ?? '')
      }));
      return [{ role: 'system', content: systemPrompt }, ...last];
    }

    // ========= Markdown rendering =========
    let md = null;
    function initMarked() {
      try {
        const MarkedClass = globalThis.marked?.Marked;
        const pluginFactory = globalThis.markedHighlight?.markedHighlight;
        if (MarkedClass) {
          md = pluginFactory
            ? new MarkedClass(pluginFactory({
                langPrefix: 'hljs language-',
                emptyLangClass: 'hljs',
                highlight(code, lang) {
                  const language = globalThis.hljs?.getLanguage(lang) ? lang : 'plaintext';
                  try { return globalThis.hljs.highlight(code, { language }).value; } catch { return code; }
                }
              }))
            : new MarkedClass();
          md.setOptions({ gfm: true, breaks: true });
        } else if (globalThis.marked?.parse) {
          md = globalThis.marked;
          md.setOptions?.({ gfm: true, breaks: true });
        }
      } catch (e) { console.warn('Marked init failed', e); }
    }
    window.addEventListener('load', () => { initMarked(); inputField?.focus?.(); });

    function sanitizeHTML(html) {
      try { if (window.DOMPurify?.sanitize) return window.DOMPurify.sanitize(html, { USE_PROFILES: { html: true } }); }
      catch (e) { console.warn('DOMPurify sanitize failed; falling back to text.', e); }
      const div = document.createElement('div'); div.textContent = html ?? ''; return div.innerHTML;
    }
    function renderMarkdownToHTML(markdown) {
      try {
        if (!md && globalThis.marked) initMarked();
        if (md) {
          const rawHTML = md.parse(String(markdown ?? ''));
          return sanitizeHTML(rawHTML);
        }
      } catch (e) { console.warn('Markdown render failed; falling back to text.', e); }
      const div = document.createElement('div'); div.textContent = String(markdown ?? ''); return div.innerHTML;
    }
    function openLinksSafely(container) {
      container.querySelectorAll('a[href]').forEach(a => {
        a.setAttribute('target', '_blank'); a.setAttribute('rel', 'noopener noreferrer');
      });
    }
    function enhanceCodeBlocks(root) {
      root.querySelectorAll('pre > code').forEach(code => {
        const pre = code.parentElement;
        const lang = [...code.classList].find(c => c.startsWith('language-'))?.slice(9) || 'text';
        const wrap = document.createElement('div'); wrap.className = 'code-wrap';
        const header = document.createElement('div'); header.className = 'code-header';
        const langEl = document.createElement('span'); langEl.className = 'lang'; langEl.textContent = lang.toUpperCase();
        const copy = document.createElement('button'); copy.className = 'copy-btn'; copy.type = 'button'; copy.textContent = 'Copy';
        copy.addEventListener('click', async () => {
          try { await navigator.clipboard.writeText(code.textContent || ''); showBanner('Copied to clipboard', true); setTimeout(hideBanner, 1000); }
          catch { showBanner('Copy failed'); }
        });
        header.appendChild(langEl); header.appendChild(copy);
        pre.replaceWith(wrap); wrap.appendChild(header); wrap.appendChild(pre);
        if (globalThis.hljs && !globalThis.markedHighlight) {
          try { globalThis.hljs.highlightElement(code); } catch {}
        }
      });
    }
    function scrollBottom() { chatContainer.scrollTop = chatContainer.scrollHeight; }

    // ========= Random utilities =========
    function shuffleInPlace(arr) {
      // Fisherâ€“Yates shuffle (unbiased, in-place)
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    } // Unbiased permutation, O(n) [6]

    // ========= Starters (pool) =========
    const START_CATEGORIES = {
      'Unity & Games': [
        'Write a Unity door interaction script with E/X/touch input.',
        'Fix overlapping colliders for a pickup system.',
        'Make a mobile FPS controller with smooth look.',
        'Create a shader for water with reflections.',
        'Design NPC dialogue with walking behavior.'
      ],
      'Web & JS': [
        'Build a page with animated route transitions.',
        'Create a debounce utility with tests.',
        'Optimize a scrollâ€‘based parallax without jank.',
        'Build a dark/light theme toggle with CSS vars.',
        'Animate a loader that respects reduced motion.'
      ],
      'Python & Streaming': [
        'Optimize Python socket streaming to hit 30+ FPS.',
        'Reduce latency with better chunking and compression.',
        'Add error correction for grainy/static frames.',
        'Profile bottlenecks in encode/decode pipeline.',
        'Implement a custom reliable UDP protocol.'
      ],
      'AI & LLM': [
        'Draft a prompt style guide for coding tasks.',
        'Explain GGUF quantization choices for 3B models.',
        'Design a fineâ€‘tuning script with LoRA adapters.',
        'Create evaluation prompts for coding tutors.',
        'Plan a retrieval pipeline for small devices.'
      ],
      'YouTube & Content': [
        'Outline a 5â€‘minute tutorial with hook and CTA.',
        'Write a thumbnail copy list with A/B variants.',
        'Draft a voiceover script with time stamps.',
        'Create a chapter structure from a transcript.',
        'Turn comments into FAQs with short answers.'
      ],
      'Translations (Indic)': [
        'Translate a Hindi paragraph to English.',
        'Localize a UI string set to Marathi.',
        'Backâ€‘translate to validate meaning in Tamil.',
        'Glossary: create consistent key terms.',
        'Detect mixedâ€‘script content and normalize.'
      ]
    };
    function generateStartersPool() {
      const pool = [];
      Object.values(START_CATEGORIES).forEach(arr => arr.forEach(s => pool.push(s)));
      const actions = ['Explain', 'Refactor', 'Summarize', 'Benchmark', 'Compare', 'Document'];
      const subjects = ['this code', 'this error', 'this design', 'this script', 'this idea'];
      actions.forEach(a => subjects.forEach(su => pool.push(`${a} ${su}.`)));
      return shuffleInPlace(pool);
    }
    let STARTERS_POOL = generateStartersPool();

    // ========= Waiting widget (typing + tips) =========
    let waitingNode = null;
    let tipsTimer = null;
    const TIPS = [
      'Tip: Press Enter to send and Shift+Enter for a new line.',
      'Pro: Paste code â€” it autoâ€‘highlights.',
      'Hint: Set Input/Reply languages to translate.',
      'Try: Ask for an outline first, then expand.'
    ];
    function showWaitingWidget() {
      hideWaitingWidget();
      const wrapper = document.createElement('div');
      wrapper.className = 'message bot waiting-card';
      wrapper.setAttribute('role', 'status');
      wrapper.setAttribute('aria-live', 'polite');
      wrapper.setAttribute('aria-atomic', 'true');

      const content = document.createElement('div'); content.className = 'content';
      const row = document.createElement('div'); row.className = 'waiting-row';
      const bubble = document.createElement('div'); bubble.className = 'typing-bubble';
      for (let i = 0; i < 3; i++) { const d = document.createElement('div'); d.className = 'typing-dot'; bubble.appendChild(d); }
      const label = document.createElement('div'); label.textContent = 'Thinkingâ€¦';
      row.appendChild(bubble); row.appendChild(label);

      const sub = document.createElement('div'); sub.className = 'waiting-subtle'; sub.textContent = TIPS[0];

      const chips = document.createElement('div'); chips.className = 'suggestion-row';
      shuffleInPlace([...STARTERS_POOL]).slice(0, 4).forEach(s => {
        const b = document.createElement('button'); b.type = 'button'; b.className = 'suggestion-chip'; b.textContent = s;
        b.onclick = () => { inputField.value = s; inputField.focus(); };
        chips.appendChild(b);
      });

      const skelWrap = document.createElement('div'); skelWrap.style.marginTop = '10px';
      for (let i = 0; i < 2; i++) { const line = document.createElement('div'); line.className = 'skeleton skel-line'; line.style.width = i === 0 ? '65%' : '48%'; skelWrap.appendChild(line); }

      content.appendChild(row); content.appendChild(sub); content.appendChild(chips); content.appendChild(skelWrap);
      const tools = document.createElement('div'); tools.className = 'msg-tools';
      const copyBtn = document.createElement('button'); copyBtn.className = 'chip-btn'; copyBtn.textContent = 'Copy';
      copyBtn.onclick = async () => { try { await navigator.clipboard.writeText(''); showBanner('Copied', true); setTimeout(hideBanner, 800); } catch {} };
      const meta = document.createElement('div'); meta.className = 'msg-meta'; meta.textContent = new Date().toLocaleTimeString();
      wrapper.appendChild(content); wrapper.appendChild(tools); tools.appendChild(copyBtn); wrapper.appendChild(meta);
      chatContainer.appendChild(wrapper);
      scrollBottom();

      let idx = 0; tipsTimer = setInterval(() => { idx = (idx + 1) % TIPS.length; sub.textContent = TIPS[idx]; }, 3500);
      waitingNode = wrapper;
    }
    function hideWaitingWidget() { if (tipsTimer) clearInterval(tipsTimer); tipsTimer = null; if (waitingNode?.parentNode) waitingNode.parentNode.removeChild(waitingNode); waitingNode = null; }

    // ========= Rendering =========
    function renderChatList() {
      chatListEl.innerHTML = '';
      conversations.forEach(c => {
        const item = document.createElement('div');
        item.className = 'chat-item' + (c.id === activeId ? ' active' : '');
        const dot = document.createElement('div'); dot.className = 'dot';
        const title = document.createElement('div'); title.className = 'title'; title.textContent = c.title || 'New Chat';
        item.appendChild(dot); item.appendChild(title);
        item.onclick = () => { activeId = c.id; renderChatList(); renderActiveConversation(); };
        chatListEl.appendChild(item);
      });
    }

    function addMessageToDOM(message) {
      const wrapper = document.createElement('div'); wrapper.classList.add('message', message.sender);
      const content = document.createElement('div'); content.className = 'content';
      if (message.sender === 'bot' && typeof message.text === 'string') {
        const clean = renderMarkdownToHTML(message.text);
        const temp = document.createElement('div'); temp.innerHTML = clean;
        openLinksSafely(temp); enhanceCodeBlocks(temp);
        content.replaceChildren(...temp.childNodes);
      } else { content.textContent = message.text ?? ''; }
      wrapper.appendChild(content);
      const tools = document.createElement('div'); tools.className = 'msg-tools';
      const copyBtn = document.createElement('button'); copyBtn.className = 'chip-btn'; copyBtn.textContent = 'Copy';
      copyBtn.onclick = async () => {
        try { const plain = content.textContent || ''; await navigator.clipboard.writeText(plain); showBanner('Copied to clipboard', true); setTimeout(hideBanner, 1000); }
        catch { showBanner('Copy failed'); }
      };
      tools.appendChild(copyBtn);
      const meta = document.createElement('div'); meta.className = 'msg-meta'; meta.textContent = message.meta || '';
      wrapper.appendChild(tools); wrapper.appendChild(meta);
      chatContainer.appendChild(wrapper);
    }

    function renderEmptyState() {
      emptyChips.innerHTML = '';
      emptyState.hidden = false;
      // Pick 2 or 4 randomly each time
      const count = Math.random() < 0.5 ? 2 : 4;
      const picks = shuffleInPlace([...STARTERS_POOL]).slice(0, count);
      picks.forEach(txt => {
        const btn = document.createElement('button'); btn.type = 'button'; btn.className = 'suggestion-chip'; btn.textContent = txt;
        btn.onclick = () => { inputField.value = txt; inputField.focus(); };
        emptyChips.appendChild(btn);
      });
    }

    function renderActiveConversation() {
      hideBanner();
      const conv = ensureActiveConversation();
      chatTitleEl.textContent = conv?.title || 'New Chat';
      chatContainer.innerHTML = '';
      emptyState.hidden = true;

      if (!conv?.messages?.length) {
        renderEmptyState();
      } else {
        (conv.messages || []).forEach(addMessageToDOM);
      }
      scrollBottom();
    }

    // ========= Initial UI =========
    ensureActiveConversation();
    renderChatList(); renderActiveConversation();

    // New / Delete chat buttons
    newChatBtn.addEventListener('click', () => {
      const conv = createConversation(); activeId = conv.id; renderChatList(); renderActiveConversation(); inputField.focus();
    });
    delChatBtn.addEventListener('click', () => {
      if (!activeId) return;
      if (confirm('Delete this chat?')) { deleteConversation(activeId); renderChatList(); renderActiveConversation(); }
    });

    // Input: Enter to send (works on start page too)
    inputField.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (typeof inputForm.requestSubmit === 'function') inputForm.requestSubmit();
        else inputForm.submit();
      }
    }); // Uses keydown + KeyboardEvent.key for consistent Enter handling [1][2]

    // ========= Networking with timeout, retry, cancel, SSE =========
    let inFlightController = null;
    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
    function backoffDelay(attempt) { const base = Math.min(BACKOFF_BASE_MS * (2 ** attempt), BACKOFF_CAP_MS); const jitter = Math.random() * 200; return base + jitter; }
    stopButton.addEventListener('click', () => {
      if (inFlightController) { inFlightController.abort(); showBanner('Request canceled.', true); }
      hideWaitingWidget();
    });

    async function readOpenAIStream(res, onDelta) {
      const reader = res.body.getReader(); const decoder = new TextDecoder();
      let buffer = ''; let content = '';
      while (true) {
        const { done, value } = await reader.read(); if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n'); buffer = lines.pop() || '';
        for (const line of lines) {
          const l = line.trim(); if (!l || l.startsWith(':')) continue; if (l === 'data: [DONE]') return content;
          if (l.startsWith('data: ')) {
            try { const json = JSON.parse(l.slice(6)); const delta = json?.choices?.[0]?.delta?.content ?? ''; if (delta) { content += delta; if (onDelta) onDelta(delta); } } catch {}
          }
        }
      }
      return content;
    }

    class RetryableError extends Error { constructor(message, status) { super(message); this.status = status; } }

    async function chatRequest(payload, onDelta) {
      let attempt = 0; let lastError = null; const t0 = performance.now();
      while (attempt <= MAX_RETRIES) {
        const controller = new AbortController(); inFlightController = controller;
        const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
        try {
          const headers = {
            'Content-Type': 'application/json',
            'Accept': USE_STREAM ? 'text/event-stream, application/json;q=0.9' : 'application/json'
          };
          if (apiKey) headers['Authorization'] = `Bearer ${apiKey}`;
          const res = await fetch(apiUrl, { method: 'POST', headers, body: JSON.stringify(payload), signal: controller.signal });
          clearTimeout(timeoutId);
          const ctype = (res.headers.get('content-type') || '').toLowerCase();
          if (USE_STREAM && ctype.includes('text/event-stream')) {
            const s = await readOpenAIStream(res, onDelta); const t1 = performance.now(); latencyChip.textContent = `${Math.round(t1 - t0)} ms`; inFlightController = null; return { choices: [{ message: { content: s } }] };
          }
          const text = await res.text(); let data; try { data = JSON.parse(text); } catch { console.error('Raw response (not JSON):', text); throw new Error('Invalid JSON response from server.'); }
          if (!res.ok || data?.error) {
            const status = res.status; const errMsg = data?.error?.message || data?.error || `HTTP ${status} ${res.statusText}`;
            if (status === 429 || (status >= 500 && status < 600)) throw new RetryableError(errMsg, status);
            throw new Error(errMsg);
          }
          const t1 = performance.now(); latencyChip.textContent = `${Math.round(t1 - t0)} ms`; inFlightController = null; return data;
        } catch (err) {
          clearTimeout(timeoutId); lastError = err;
          const isAbort = err?.name === 'AbortError' || err?.message?.includes('aborted'); if (isAbort) throw err;
          const status = err?.status;
          const retryable = err instanceof RetryableError || status === 429 || (status >= 500 && status < 600) || !status;
          if (retryable && attempt < MAX_RETRIES) { const wait = backoffDelay(attempt); showBanner(`Retryingâ€¦ attempt ${attempt + 2}/${MAX_RETRIES + 1} in ${Math.round(wait)}ms`); await sleep(wait); attempt++; continue; }
          throw err;
        } finally { inFlightController = null; }
      }
      throw lastError || new Error('Unknown error');
    }

    // ========= Local translator client (IndicTrans2 FastAPI) =========
    async function translateLocal(text, srcFlores, tgtFlores, num_beams = 3, max_length = 256) {
      if (!text || srcFlores === tgtFlores) return text;
      const body = { text, src_lang: srcFlores, tgt_lang: tgtFlores, num_beams, max_length };
      const res = await fetch(`${TRANS_BASE}/translate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      if (!res.ok) throw new Error(`Translator failed (${res.status})`);
      const data = await res.json().catch(() => ({}));
      const out = Array.isArray(data?.translations) ? data.translations : null;
      return out || text;
    }

    // Normalize any value to a plain text string
    function toText(v) {
      if (Array.isArray(v)) return v.join(' ');
      if (v == null) return '';
      return String(v);
    }

    // Heuristic Unicode script guess -> FLORES code
    function guessFloresByScript(text) {
      const ranges = [
        { re: /[\u0900-\u097F]/, code: 'hin_Deva' },{ re: /[\u0980-\u09FF]/, code: 'ben_Beng' },{ re: /[\u0A00-\u0A7F]/, code: 'pan_Guru' },{ re: /[\u0A80-\u0AFF]/, code: 'guj_Gujr' },
        { re: /[\u0B00-\u0B7F]/, code: 'ory_Orya' },{ re: /[\u0B80-\u0BFF]/, code: 'tam_Taml' },{ re: /[\u0C00-\u0C7F]/, code: 'tel_Telu' },{ re: /[\u0C80-\u0CFF]/, code: 'kan_Knda' },
        { re: /[\u0D00-\u0D7F]/, code: 'mal_Mlym' },{ re: /[\u0600-\u06FF]/, code: 'urd_Arab' },{ re: /[\u1C50-\u1C7F]/, code: 'mni_Mtei' },{ re: /[\u1C00-\u1C4F]/, code: 'sat_Olck' },
      ];
      for (const r of ranges) if (r.re.test(text)) return r.code;
      return 'eng_Latn';
    }

    // ========= Submit handler (translateâ†’chatâ†’translate) =========
    const inputFormEl = document.getElementById('input-form');
    inputFormEl.addEventListener('submit', async (e) => {
      e.preventDefault(); hideBanner();

      const userMessage = inputField.value.trim(); if (!userMessage) return;

      // Ensure active chat exists (auto-create/select)
      let conv = ensureActiveConversation();

      // Immediately hide empty suggestions once conversation starts
      emptyState.hidden = true;

      const userChat = { sender: 'user', text: userMessage, meta: new Date().toLocaleTimeString() };
      conv.messages.push(userChat);
      if (conv.title === 'New Chat') updateTitleFromFirstUser(conv);
      saveConversations(); renderChatList();
      addMessageToDOM(userChat);

      inputField.value = ''; inputField.focus();
      sendButton.disabled = true; stopButton.style.display = 'inline-block';
      showWaitingWidget();

      try {
        // Determine languages
        let srcFlores = srcLangSel.value === 'auto' ? guessFloresByScript(userMessage) : srcLangSel.value;
        let outFlores = tgtLangSel.value === 'same' ? srcFlores : tgtLangSel.value;

        // Translate user -> English if needed
        const userInEnglishRaw = (srcFlores === 'eng_Latn') ? userMessage : await translateLocal(userMessage, srcFlores, 'eng_Latn');
        const userInEnglish = toText(userInEnglishRaw);

        // Build payload with English user content
        const payload = { model: modelName, stream: false, messages: buildMessagesPayload(conv) };
        for (let i = payload.messages.length - 1; i >= 0; i--) {
          if (payload.messages[i].role === 'user') { payload.messages[i] = { role: 'user', content: userInEnglish }; break; }
        }

        // Call chat (non-streaming)
        const t0 = performance.now();
        const data = await chatRequest(payload);
        const t1 = performance.now(); latencyChip.textContent = `${Math.round(t1 - t0)} ms`;

        // Ensure reply content is a string
        const replyEn = toText(data?.choices?.[0]?.message?.content ?? '');

        // Translate English reply -> output language if needed
        const replyOutRaw = (outFlores === 'eng_Latn') ? replyEn : await translateLocal(replyEn, 'eng_Latn', outFlores);
        const replyOut = toText(replyOutRaw);

        const botMessage = { sender: 'bot', text: replyOut, meta: new Date().toLocaleTimeString() };
        addMessageToDOM(botMessage);
        conv.messages.push(botMessage); saveConversations(); scrollBottom();
        showBanner('Done', true); setTimeout(hideBanner, 700);
      } catch (err) {
        console.error('Chat error:', err);
        const errorMessage = { sender: 'bot', text: `Error: ${err.message}`, meta: new Date().toLocaleTimeString() };
        conv.messages.push(errorMessage); addMessageToDOM(errorMessage); saveConversations();
        showBanner(`Send failed: ${err.message}`);
      } finally {
        hideWaitingWidget();
        sendButton.disabled = false; stopButton.style.display = 'none'; inputField.focus();
      }
    });
  </script>
</body>
</html>
